#define MAX_TEXTURES 30

//globals
Texture2D shaderTexture;
Texture2D shaderTextures[MAX_TEXTURES];
SamplerState SampleType;

cbuffer Light
{
 float4 ambientColor;
 float4 diffuseColor;
 float3 lightDirection;
 float specularPower;
 float4 specularColor;
};

cbuffer Colors
{
 float
}

cbuffer PixelColor
{
 float4 pixelColor;
}

struct PixelInput
{
  float4 position : SV_POSITION;
  float2 tex : TEXCOORD0;
  float3 normal : NORMAL;
  float3 viewDirection : TEXCOORD1;
};

struct TexturePixelInput
{
 float4 position: SV_POSITION;
 float2 tex : TEXCOORD0;
};

struct ColorPixelInput
{
 float4 position: SV_POSITION;
 float4 color : COLOR;
};

struct TerrainPixelInput
{
 float4 position : SV_POSITION;
 float2 tex :TEXCOORD0;
 float3 normal : NORMAL;
};


float4 defualtPixelShader(PixelInput input) :SV_TARGET
{
   float4 textureColor;
   float3 lightDir;
   float lightIntensity;
   float4 color;
   float3 reflection;
   float4 specular;

   //Sample the pixel color from the texture using the sampler at this texture coordinate
   textureColor = shaderTexture.Sample(SampleType,input.tex);

   //Set the defulat output color to the ambient light value for all pixels.
   color = ambientColor;

   //init the specular color
   specular = float4(0.0f,0.0f,0.0f,0.0f);

   //Invert the light direction for calculations
   lightDir = -lightDirection;

   //Calculate the amount of light on this pixel.
   lightIntensity = saturate(dot(input.normal,lightDir));

   if(lightIntensity > 0.0f)
   {
     //determin the final diffuse color based on the diffuse color and the amount of light
	 color += (diffuseColor * lightIntensity);

	 //Saturate the ambient and diffuse color
	 color = saturate(color);

	 //Calcualte the reflection vector based on the light intensity,normal vector and light direction
	 reflection = normalize(2*lightIntensity*input.normal - lightDir);

	 //Determine the amount of specular light based on the relfection vector,viewing direction and specular power.
	 specular = pow(saturate(dot(reflection,input.viewDirection)),specularPower);
   }

   //Multiply the texture and the final diffuse color to get the final pixel color
   color = color * textureColor;

   //Add the specular componenet last to the output color
   color = saturate(color + specular);
   
   return color;
}

float4 texturePixelShader(TexturePixelInput input) :SV_TARGET
{
   float4 textureColor;

   //Sample the pixel color from the texture using the sampler at this texture coordinate
   textureColor = shaderTexture.Sample(SampleType,input.tex);

   
   return textureColor;
}

float4 fontPixelShader(TexturePixelInput input) :SV_TARGET
{
   float4 color;
   //Sample the pixel color from the texture using the sampler at this texture coordinate
   color = shaderTexture.Sample(SampleType,input.tex);
   //if the color is black on the texture then treat this pixel as transparent.
   if(color.r == 0.0f)
   {
    color.a = 0.0f;
   }
   //if the color is other then black on the texture then this is a pixel in the font so draw it using the font color.
   else
   {
    color.a = 1.0f;
    color = color*ambientColor;
   }
   

   return color;
}

float4 colorPixelShader(ColorPixelInput input): SV_TARGET
{
 return input.color;
}

float4 terrainPixelShader(TerrainPixelInput input) : SV_TARGET
{
 float4 textureColor;
 float3 lightDir;
 float lightIntensity;
 float4 color;
 
 //Sample the pixel color from the texture using the sampler at this coordinate location
 textureColor = shaderTexture.Sample(SampleType,input.tex);
 
 //set the defualt output color to the ambient light value for all pixels
 color = ambientColor;
 
 //invert the light direction for calculations
 lightDir = -lightDirection;
 
 //Calculate the amount of light on this pixel.
 lightIntensity = saturate(dot(input.normal,lightDir));
 
 if(lightIntensity > 0.0)
 {
  //determine the final diffuse color based on the diffuse color and the amount of light intensity
  color += (diffuseColor * lightIntensity);
  }

 
 //saturate the final light color
 color = saturate(color);
 
 //Multiply the texture pixel and the final light color to get the result
 color = color* textureColor;


 return color;
}



